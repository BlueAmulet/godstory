//-----------------------------------------------------------------------------
// PowerEngine Ground Cover
// Copyright (C) Sickhead Games, LLC
//-----------------------------------------------------------------------------

#include "platform/platform.h"
#include "T3D/fx/groundCover.h"

#include "core/bitStream.h"
#include "console/consoleTypes.h"
#include "sceneGraph/sceneState.h"
#include "terrain/terrData.h"
#include "renderInstance/renderInstMgr.h"
#include "gfx/gfxDrawUtil.h"
#include "gfx/primBuilder.h"
#include "T3D/gameConnection.h"
#include "gfx/gfxVertexBuffer.h"
#include "gfx/gfxStructs.h"
#include "ts/tsShapeInstance.h"
#include "sceneGraph/lightManager.h"
#include "sceneGraph/lightInfo.h"
#include "sceneGraph/lightAllocator.h"
#include "T3D/fx/windEmitter.h"

// Make sure this exists in your $project/game/shaders folder
// This works because of the ../../../game/shaders in Additional
// Include Directories that is on each project (as set in project.conf
// and generated by the Project Generator)
#include "legacyTerrain/groundCover.h"
#include "gfx/D3D9/gfxD3D9StateBlock.h"
//---------------------------------------------------------------------------
//静态成员和宏定义
//状态块
//---------------------------------------------------------------------------
//////#define STATEBLOCK
GFXStateBlock* GroundCover::mSetInitSB = NULL;
GFXStateBlock* GroundCover::mSetSB = NULL;

// This class acts as a dummy SceneObject which will
// pass rendering state down for TSMesh rendering.
class TSSceneObjectHelper : public SceneObject
{
public:
   TSSceneObjectHelper() 
   {
   }

   void setState( const Box3F& objBox, const MatrixF& worldMat, const VectorF& scale )
   {
      mObjBox = objBox;
      mRenderObjToWorld = worldMat;
      mRenderWorldToObj = worldMat;
      mRenderWorldToObj.affineInverse();
      mObjScale = scale;
   }
};


/// This is used for rendering ground cover billboards.
DEFINE_VERT( GCVertex, 
   GFXVertexFlagXYZ | GFXVertexFlagDiffuse |
   GFXVertexFlagTextureCount1 | GFXVertexFlagUVWQ0 )
{
   Point3F point;

   // .rgb = ambient
   // .a = corner index
   GFXVertexColor ambient;

   // .x = size x
   // .y = size y
   // .z = type
   // .w = wind amplitude
   Point4F params;
};

/// This defines one grid cell.
class GroundCoverCell
{
protected:

   friend class GroundCover;

   struct Placement
   {
      Point3F     point;
      Point3F     size;
      F32         rotation;
      U32         type;
      F32         windAmplitude;
      Box3F       worldBox;
      ColorF      lmColor;
   };

   /// This is the x,y index for this cell.
   Point2I mIndex;

   /// The worldspace bounding box this cell.
   Box3F mBounds;

   /// The worldspace bounding box of the renderable
   /// content within this cell.
   Box3F mRenderBounds;

   /// The instances of billboard cover elements in this cell.
   Vector<Placement> mBillboards;

   /// The instances of shape cover elements in this cell.
   Vector<Placement> mShapes;

   typedef GFXVertexBufferHandle<GCVertex> VBHandle;
   typedef Vector< VBHandle > VBHandleVector;

   /// The vertex buffers that hold all the 
   /// prepared billboards for this cell.
   VBHandleVector mVBs;

   /// Used to mark the cell dirty and in need
   /// of a rebuild.
   bool mDirty;

   /// Repacks the billboards into the vertex buffer.
   void _rebuildVB();

public:

   GroundCoverCell() {}

   ~GroundCoverCell() 
   {
      mVBs.clear();
   }

   const Point2I& shiftIndex( const Point2I& shift ) { return mIndex += shift; }
   
   /// The worldspace bounding box this cell.
   const Box3F& getBounds() const { return mBounds; }

   /// The worldspace bounding box of the renderable
   /// content within this cell.
   const Box3F& getRenderBounds() const { return mRenderBounds; }

   Point3F getCenter() const { return ( mBounds.min + mBounds.max ) / 2.0f; }

   VectorF getSize() const { return VectorF( mBounds.len_x() / 2.0f,
                                             mBounds.len_y() / 2.0f,
                                             mBounds.len_z() / 2.0f ); }
   
   static void initRender( GFXShader* shader, 
                           const MatrixF& camMat,
                           F32 startFade, 
                           F32 endFade,
                           F32 maxBillboardTiltRads,
                           GFXTexHandle& texture,
                           const RectF coverRect[6] );

   /// Renders all the billboard batches returning the 
   /// total billboards rendered.
   U32 renderBillboards(   const LightInfoList& lights,
                           const WindEmitterList& emitters,
                           GFXPrimitiveBufferHandle& primBuffer );

   U32 renderShapes(    SceneState *state, 
                        FrustrumCuller* culler, 
                        TSSceneObjectHelper& helper,
                        LightAllocator* lightAllocator,
                        TSShapeInstance** shapes );
};

void GroundCoverCell::_rebuildVB()
{
   if ( mBillboards.empty() )
      return;

   PROFILE_SCOPE(GroundCover_RebuildVB);

   // The maximum verts we can put in one vertex buffer batch.
   const U32 MAX_BILLBOARDS = 0xFFFF / 4;

   // How many batches will we need in total?
   const U32 batches = mCeil( (F32)mBillboards.size() / (F32)MAX_BILLBOARDS );

   // So... how many billboards do we need in
   // each batch? We're trying to evenly divide
   // the amount across all the VBs.
   const U32 batchBB = mBillboards.size() / batches;

   // Init the vertex buffer list to the right size.  Any
   // VBs already in there will remain unless we're truncating
   // the list... those are freed.
   mVBs.setSize( batches ); 

   // Get the iter to the first billboard.
   Vector<Placement>::const_iterator iter = mBillboards.begin();

   // Prepare each batch.
   U32 bb, remaining = mBillboards.size();
   for ( U32 b = 0; b < batches; b++ )
   {
      // Grab a reference to the vb.
      VBHandle &vb = mVBs[b];

      // How many billboards in this batch?
      bb = getMin( batchBB, remaining );
      remaining -= bb;

      // Ok... now how many verts is that?
      const U32 verts = bb * 4;

      // Create the VB hasn't been created or if its
      // too small then resize it.
      if ( vb.isNull() || vb->mNumVerts < verts )
      {
         PROFILE_START(GroundCover_CreateVB);
         vb.set( GFX, verts, GFXBufferTypeStatic );
         PROFILE_END(GroundCover_CreateVB);
      }

      // Fill this puppy!
      GCVertex* vertPtr = vb.lock( 0, verts );
      
      GFXVertexColor color;

      Vector<Placement>::const_iterator last = iter + bb;
      for ( ; iter != last; iter++ )
      {
         const Point3F &position = (*iter).point;
         const S32 &type = (*iter).type;
         const Point3F &size = (*iter).size;
         const F32 &windAmplitude = (*iter).windAmplitude;
         GFXVertexColor color = (ColorI)(*iter).lmColor;
         U8 *col = (U8 *)const_cast<U32 *>( (const U32 *)color );

         vertPtr->point = position;
         vertPtr->params.x = size.x;
         vertPtr->params.y = size.y;
         vertPtr->params.z = type;
         vertPtr->params.w = 0;
         col[3] = 0;
         vertPtr->ambient = color;
         ++vertPtr;

         vertPtr->point = position;
         vertPtr->params.x = size.x;
         vertPtr->params.y = size.y;
         vertPtr->params.z = type;
         vertPtr->params.w = 0;
         col[3] = 1;
         vertPtr->ambient = color;
         ++vertPtr;

         vertPtr->point = position;
         vertPtr->params.x = size.x;
         vertPtr->params.y = size.y;
         vertPtr->params.z = type;
         vertPtr->params.w = windAmplitude;
         col[3] = 2;
         vertPtr->ambient = color;
         ++vertPtr;

         vertPtr->point = position;
         vertPtr->params.x = size.x;
         vertPtr->params.y = size.y;
         vertPtr->params.z = type;
         vertPtr->params.w = windAmplitude;
         col[3] = 3;
         vertPtr->ambient = color;
         ++vertPtr;
      }

      vb.unlock();
   }
}


void GroundCoverCell::initRender(   GFXShader* shader, 
                                    const MatrixF& camMat, 
                                    F32 startFade, 
                                    F32 endFade,
                                    F32 maxBillboardTiltRads,
                                    GFXTexHandle& texture,
                                    const RectF coverRect[6] )
{
   PROFILE_SCOPE(GroundCoverCell_initRender);
#ifdef STATEBLOCK
	AssertFatal(GroundCover::mSetInitSB, "GroundCoverCell::initRender -- GroundCover::mSetInitSB cannot be NULL.");
	GroundCover::mSetInitSB->apply();
#else
	GFX->setTextureStageAddressModeU( 0, GFXAddressClamp );
	GFX->setTextureStageAddressModeV( 0, GFXAddressClamp );
	GFX->setTextureStageAddressModeU( 1, GFXAddressClamp );
	GFX->setTextureStageAddressModeV( 1, GFXAddressClamp );

	GFX->setStencilEnable( false );

	GFX->setZEnable( true );

	GFX->setAlphaBlendEnable( false );
	GFX->setAlphaTestEnable( true );
	GFX->setAlphaRef( 84 );
	GFX->setAlphaFunc( GFXCmpGreater );

	GFX->setCullMode( GFXCullNone );
#endif


   // Setup the shader.
   GFX->setShader( shader );


   // Get the data we need from the camera matrix.
   MatrixF camMatTrans = camMat;
   camMat.transposeTo( camMatTrans );

   const VectorF *camRight = (VectorF *)&camMatTrans[0];
   const VectorF *camDir = (VectorF *)&camMatTrans[4];
   VectorF *camUp = (VectorF *)&camMatTrans[8];

   // Limit the camera up vector to keep the billboards 
   // from leaning too far down into the terrain.
   VectorF lookDir( camDir->x, camDir->y, 0.0f );
   F32 angle;
   if ( !lookDir.isZero() )
   {
      lookDir.normalize();
      angle = mAcos( mDot( *camUp, lookDir ) );
   }
   else
   {
      angle = camDir->z < 0.0f ? 0.0f : ( M_PI_F / 2.0f );
   }

   if ( angle < (M_PI_F / 2.0f) - maxBillboardTiltRads )
   {
      PROFILE_SCOPE(GroundCoverCell_QuatF_STUFF);
      QuatF quat( AngAxisF( *camRight, maxBillboardTiltRads ) );
      quat.mulP( VectorF( 0.0f, 0.0f, 1.0f ), camUp );
   }

   // Setup the shader consts for the camera.
   GFX->setVertexShaderConstF( 6, camMatTrans, 4 );

   // Setup the fade parameters.
   Point4F fadeParams( startFade, endFade, 0.0f, 0.0f );
   GFX->setVertexShaderConstF( 10, (F32*)&fadeParams, 1 );

   // Setup the texture.
   GFX->setTexture( 0, texture );

   // Pass the cover rects.
   GFX->setVertexShaderConstF( 60, (F32*)coverRect, 6 );
}

U32 GroundCoverCell::renderShapes(  SceneState *state, 
                                    FrustrumCuller* culler, 
                                    TSSceneObjectHelper& helper, 
                                    LightAllocator* lightAllocator,
                                    TSShapeInstance** shapes )
{
   MatrixF worldMat;
   TSShapeInstance* shape;
   Point3F camVector;
   F32 dist;
   F32 invScale;

   const S32 cullerMasks = FrustrumCuller::ClipPlaneMask | FrustrumCuller::FarSphereMask;

   U32 totalRendered = 0;

   Vector<Placement>::const_iterator iter = mShapes.begin();
   for ( ; iter != mShapes.end(); iter++ )
   {
      // Grab a reference here once.
      const Placement& inst = (*iter);

      // If we were pass a culler then us it to test the shape world box.
      if ( culler && culler->testBoxVisibility( inst.worldBox, cullerMasks, 0 ) == -1 )
         continue;

      shape = shapes[ inst.type ];

      camVector = inst.point - state->getCameraPosition();
      dist = getMax( camVector.len(), 0.01f );

      worldMat.set( EulerF(0, 0, inst.rotation), inst.point );
      helper.setState( shape->getShape()->bounds, worldMat, inst.size );

      // TSShapeInstance::render() uses the 
      // world matrix for the RenderInst.
      worldMat.scale( inst.size );
      GFX->setWorldMatrix( worldMat );

      // Obey the normal screen space lod metrics.  The shapes should
      // be tuned to lod out quickly for ground cover.
      //
      // Note: The profile doesn't indicate that lod selection is
      // very expensive... in fact its less than 1/10th of the cost 
      // of the render() call below.
      PROFILE_START(GroundCover_RenderShapes_SelectDetail);

         invScale = (1.0f/getMax(getMax(inst.size.x,inst.size.y),inst.size.z));
         shape->selectCurrentDetail2( dist * invScale );

      PROFILE_END(GroundCover_RenderShapes_SelectDetail); // GroundCover_RenderShapes_SelectDetail
   
      // Note: This is the most expensive call of this loop.  We 
      // need to rework the render call completely to optimize it.
      PROFILE_START(GroundCover_RenderShapes_Render);

         shape->render();

      PROFILE_END(GroundCover_RenderShapes_Render); // GroundCover_RenderShapes_Render

      totalRendered++;
   }

   return totalRendered;
}

U32 GroundCoverCell::renderBillboards( const LightInfoList& lights, 
                                       const WindEmitterList& emitters,
                                       GFXPrimitiveBufferHandle& primBuffer )
{
   if ( mDirty )
   {
      _rebuildVB();
      mDirty = false;
   }

   // Do we have anything to render?
   if ( mBillboards.size() == 0 || mVBs.empty() )
      return 0;

   // Setup two lights for the shader to process... 
   ColorF lightColor;
   Point3F lightPosition;
   F32 oneOverLightRadius;
   for ( S32 i=0; i < MAX_POINT_LIGHTS; i++ )
   {
      // Collect the light data.
      LightInfo* light = lights.size() > i ? lights[i] : NULL;
      if ( !light || !( light->mType == LightInfo::Point || light->mType == LightInfo::SGStaticPoint ) || light->mRadius <= 0.001f )
      {
         // We have no light here... set the radius to
         // zero to disable it in the shader.
         oneOverLightRadius = 0;
      }
      else
      {
         lightColor = light->mColor;
         lightPosition = light->mPos;
         oneOverLightRadius = 1.0f / light->mRadius;
      }

      // Setup the shader!
      const U32 startReg = 0;
      GFX->setPixelShaderConstF( startReg + (i*3) + 0, (F32*)&lightColor, 1 );
      GFX->setPixelShaderConstF( startReg + (i*3) + 1, (F32*)&lightPosition, 1, 3 );
      GFX->setPixelShaderConstF( startReg + (i*3) + 2, (F32*)&oneOverLightRadius, 1, 1 );
   }

   // Setup the wind emitters!
   const F32 simTime = Sim::getCurrentTime() * 0.001f;
   for ( S32 i=0; i < MAX_WIND_EMITTERS; i++ )
   {
      // Collect a sphere.
      WindEmitter* sphere = emitters.size() > i ? emitters[i] : NULL;
      Point4F placement( 0.0f, 0.0f, 0.0f, 0.0f );
      Point4F effect( 0.0f, 0.0f, 0.0f, 0.0f );
      if ( sphere && sphere->getRadius() > 0.0f )
      {
         placement = sphere->getCenter();
         placement.w = 1.0f / sphere->getRadius();
         effect.x = sphere->getStrength();
         effect.y = sphere->getTurbulenceFrequency() * simTime;
         effect.z = sphere->getTurbulenceStrength();
      }

      // We pack the wind emitter as follows...
      //
      // .xyz = position
      // .w = one over radius   
      // float4 placement;
      //
      // .x = strength
      // .y = turbulence frequency
      // .z = turbulence strength
      // .w = unused
      // float4 effect;
      const U32 startReg = 40;
      GFX->setVertexShaderConstF( startReg + (i*2) + 0, (F32*)&placement, 1 );
      GFX->setVertexShaderConstF( startReg + (i*2) + 1, (F32*)&effect, 1 );
   }


   // TODO: Maybe add support for non-facing billboards
   // with random rotations and optional crosses.  We could
   // stick them into the buffer after the normal billboards,
   // then change shader consts.
   //

   // Setup the primitive buffer once.
   GFX->setPrimitiveBuffer( primBuffer );

   // Draw each batch.
   U32 remaining = mBillboards.size();
   const U32 batches = mVBs.size();
   const U32 batchBB = remaining / batches;

   for ( U32 b = 0; b < batches; b++ )
   {
      // Grab a reference to the vb.
      VBHandle &vb = mVBs[b];

      // How many billboards in this batch?
      U32 bb = getMin( batchBB, remaining );
      remaining -= bb;

      // Setup and render it!
      GFX->setVertexBuffer( vb );
      GFX->drawIndexedPrimitive( GFXTriangleList,
                                 0, 
                                 bb * 4, 
                                 0, 
                                 bb * 2 );
   }

   return mBillboards.size();
}


U32 GroundCover::smStatRenderedCells = 0;
U32 GroundCover::smStatRenderedBillboards = 0;
U32 GroundCover::smStatRenderedBatches = 0;
U32 GroundCover::smStatRenderedShapes = 0;
U32 GroundCover::smLastState = 0;
F32 GroundCover::smQualityScale = 1.0f;

GroundCover::GroundCover()
{
   mTypeMask |= StaticObjectType;
   mNetFlags.set( Ghostable | ScopeAlways );

   mRadius = 200.0f;
   mZOffset = 0.0f;
   mFadeRadius = 50.0f;
   mShapeCullRadius = 75.0f;
   mReflectRadiusScale = 0.25f;

   mGridSize = 7;

   // By initializing this to a big value we
   // ensure we warp on first render.
   mGridIndex.set( S32_MAX, S32_MAX );

   mMaxPlacement = 1000;
   mLastPlacementCount = 0;

   mDebugRenderCells = false;
   mDebugNoBillboards = false;
   mDebugNoShapes = false;
   mDebugLockFrustum = false;

   mRandomSeed = 1;

   mTerrainName = NULL;
   mTerrainBlock = NULL;
   mTerrainGhostId = 0;

   mTextureName = NULL;

   mBBShader = NULL;
   mLightAllocator = NULL;

   mMaxBillboardTiltAngle = 90.0f;

   // TODO: This really doesn't belong here... we need a
   // real wind system for PowerEngine scenes.  This data
   // would be part of a global scene wind or area wind
   // emitter.
   //
   // Tom Spilman - 10/16/2007

   mWindGustLength = 20.0f;
   mWindGustFrequency = 0.5f;
   mWindGustStrength = 0.5f;
   mWindDirection.set( 1.0f, 0.0f );
   mWindTurbulenceFrequency = 1.2f;
   mWindTurbulenceStrength = 0.125f;

   for ( S32 i=0; i < NumCoverTypes; i++ )
   {
      mProbability[i] = 1.0f;

      mSizeMin[i] = 1.0f;
      mSizeMax[i] = 1.0f;
      mSizeExponent[i] = 1.0f;

      mWindScale[i] = 1.0f;

      mMaxSlope[i] = 0.0f;

      mMinElevation[i] = -99999.0f;
      mMaxElevation[i] = 99999.0f;

      mLayer[i] = -1;
      mInvertLayer[i] = false;

      mMinClumpCount[i] = 1;
      mMaxClumpCount[i] = 1;
      mClumpCountExponent[i] = 1.0f;
      mClumpRadius[i] = 1.0f;

      mBillboardRects[i].point.set( 0.0f, 0.0f );
      mBillboardRects[i].extent.set( 1.0f, 1.0f );

      mShapeFilenames[i] = NULL;
      mShapeInstances[i] = NULL;

      mBillboardAspectScales[i] = 1.0f;

      mNormalizedProbability[i] = 0.0f;
   }
}

IMPLEMENT_CO_NETOBJECT_V1(GroundCover);

void GroundCover::initPersistFields()
{
   Parent::initPersistFields();

   addGroup( "Wind" );

      addField( "windDirection", TypePoint2F, Offset( mWindDirection, GroundCover ) );

      addField( "windGustLength", TypeF32, Offset( mWindGustLength, GroundCover ) );
      addField( "windGustFrequency", TypeF32, Offset( mWindGustFrequency, GroundCover ) );
      addField( "windGustStrength", TypeF32, Offset( mWindGustStrength, GroundCover ) );

      addField( "windTurbulenceFrequency", TypeF32, Offset( mWindTurbulenceFrequency, GroundCover ) );
      addField( "windTurbulenceStrength", TypeF32, Offset( mWindTurbulenceStrength, GroundCover ) );

   endGroup( "Wind" );

   addGroup( "Ground Cover General" );
      
      addField( "radius", TypeF32, Offset( mRadius, GroundCover ) );
      addField( "dissolveRadius", TypeF32, Offset( mFadeRadius, GroundCover ) );
      addField( "reflectScale", TypeF32, Offset( mReflectRadiusScale, GroundCover ) );

      addField( "gridSize", TypeS32, Offset( mGridSize, GroundCover ) );
      addField( "zOffset", TypeF32, Offset( mZOffset, GroundCover ) );

      addField( "seed", TypeS32, Offset( mRandomSeed, GroundCover ) );
      addField( "terrain", TypeString, Offset( mTerrainName, GroundCover ) );
      addField( "maxElements", TypeS32, Offset( mMaxPlacement, GroundCover ) );

   endGroup( "Ground Cover General" );

   addGroup( "Ground Cover Billboard" );

      addField( "billboardTexture", TypeFilename, Offset( mTextureName, GroundCover ) );
      addField( "maxBillboardTiltAngle", TypeF32, Offset( mMaxBillboardTiltAngle, GroundCover ) );

   endGroup( "Ground Cover Billboard" );

   addGroup( "Ground Cover Shape" );

      addField( "shapeCullRadius", TypeF32, Offset( mShapeCullRadius, GroundCover ) );      
   endGroup( "Ground Cover Shape" );


   addGroup( "Ground Cover Debug" );

      addField( "lockFrustum", TypeBool, Offset( mDebugLockFrustum, GroundCover ) );
      addField( "renderCells", TypeBool, Offset( mDebugRenderCells, GroundCover ) );
      addField( "noBillboards", TypeBool, Offset( mDebugNoBillboards, GroundCover ) );
      addField( "noShapes", TypeBool, Offset( mDebugNoShapes, GroundCover ) );

   endGroup( "Ground Cover Debug" );  

   UTF8 groupName[256];
   UTF8 fieldName[256];
   for ( S32 i=0; i < NumCoverTypes; i++ )
   {
      dSprintf( groupName, sizeof( groupName ), "Ground Cover Type %d", i );
      addGroup( groupName );

         dSprintf( fieldName, sizeof( fieldName ), "billboardUVs%d", i );
         addField( fieldName, TypeRectF, Offset( mBillboardRects[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "shapeFilename%d", i );      
         addField( fieldName, TypeFilename, Offset( mShapeFilenames[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "layer%d", i );
         addField( fieldName, TypeS32, Offset( mLayer[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "invertLayer%d", i );
         addField( fieldName, TypeBool, Offset( mInvertLayer[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "probability%d", i );
         addField( fieldName, TypeF32, Offset( mProbability[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "sizeMin%d", i );
         addField( fieldName, TypeF32, Offset( mSizeMin[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "sizeMax%d", i );
         addField( fieldName, TypeF32, Offset( mSizeMax[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "sizeExponent%d", i );
         addField( fieldName, TypeF32, Offset( mSizeExponent[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "windScale%d", i );
         addField( fieldName, TypeF32, Offset( mWindScale[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "maxSlope%d", i );
         addField( fieldName, TypeF32, Offset( mMaxSlope[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "minElevation%d", i );
         addField( fieldName, TypeF32, Offset( mMinElevation[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "maxElevation%d", i );
         addField( fieldName, TypeF32, Offset( mMaxElevation[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "minClumpCount%d", i );
         addField( fieldName, TypeS32, Offset( mMinClumpCount[i], GroundCover ) );
         
         dSprintf( fieldName, sizeof( fieldName ), "maxClumpCount%d", i );
         addField( fieldName, TypeS32, Offset( mMaxClumpCount[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "clumpExponent%d", i );
         addField( fieldName, TypeF32, Offset( mClumpCountExponent[i], GroundCover ) );

         dSprintf( fieldName, sizeof( fieldName ), "clumpRadius%d", i );
         addField( fieldName, TypeF32, Offset( mClumpRadius[i], GroundCover ) );

      endGroup( groupName );
   }
}

void GroundCover::consoleInit()
{  
   Con::addVariable( "$GroundCover::renderedCells", TypeS32, &smStatRenderedCells );
   Con::addVariable( "$GroundCover::renderedBillboards", TypeS32, &smStatRenderedBillboards );
   Con::addVariable( "$GroundCover::renderedBatches", TypeS32, &smStatRenderedBatches );
   Con::addVariable( "$GroundCover::renderedShapes", TypeS32, &smStatRenderedShapes );
}

void GroundCover::onGhostAlwaysDone()
{
   // Find the terrain object on the server... the client waits until
   // it receives the ghost update of the ghost id
   if ( isServerObject() )
   {
      StringTableEntry terrainName = mTerrainName;
      if ( !terrainName || !terrainName[0] )
         terrainName = StringTable->insert( "Terrain" );

      mTerrainBlock = dynamic_cast<TerrainBlock*>( Sim::findObject( terrainName ) );
      mTerrainGhostId = 0;

      setMaskBits( TerrainBlockMask );
   }
}

bool GroundCover::onAdd()
{
   if (!Parent::onAdd())
      return false;

   // We don't use any bounds.
	mObjBox.min.set(-1e5, -1e5, -1e5);
	mObjBox.max.set( 1e5,  1e5,  1e5);
   resetWorldBox();

   // Prepare some client side things.
   if ( isClientObject() )
   {
      mBBShader = NULL;
      if ( !Sim::findObject( "GroundCoverShaderData", mBBShader ) )
         Con::warnf("GroundCover - failed to locate billboard shader GroundCoverShaderData!");

      mLightAllocator = new LightAllocator();

      _initShapes();
   }

   addToScene();

   NetConnection::smGhostAlwaysDone.notify( this, &GroundCover::onGhostAlwaysDone );

   return true;
}

void GroundCover::onRemove()
{
   Parent::onRemove();

   _deleteCells();
   _deleteShapes();

   if ( isClientObject() && mTerrainBlock )
      mTerrainBlock->mUpdateSignal.remove( this, &GroundCover::onTerrainUpdated );

   NetConnection::smGhostAlwaysDone.remove( this, &GroundCover::onGhostAlwaysDone );

   mTerrainBlock = NULL;
   mBBShader = NULL;

   SAFE_DELETE( mLightAllocator );

   removeFromScene();
}

void GroundCover::inspectPostApply()
{
   Parent::inspectPostApply();

   // We flag all the parameters as changed because
   // we're feeling lazy and there is not a good way
   // to track what parameters changed.
   //
   // TODO: Add a mask bit option to addField() and/or
   // addGroup() which is passed to inspectPostApply
   // for detection of changed elements.
   //
   setMaskBits( -1 );
}

U64 GroundCover::packUpdate( NetConnection *connection, U64 mask, BitStream *stream )
{
   Parent::packUpdate( connection, mask, stream );

   if (stream->writeFlag(mask & InitialUpdateMask))
   {
      // TODO: We could probably optimize a few of these
      // based on reasonable units at some point.

      stream->write( mRadius );
      stream->write( mZOffset );
      stream->write( mFadeRadius );
      stream->write( mShapeCullRadius );
      stream->write( mReflectRadiusScale );
      stream->write( mGridSize );
      stream->write( mRandomSeed );
      stream->write( mMaxPlacement );
      stream->write( mMaxBillboardTiltAngle );

      stream->writeString( mTextureName );

      stream->write( mWindDirection.x );
      stream->write( mWindDirection.y );
      stream->write( mWindGustLength );
      stream->write( mWindGustFrequency );
      stream->write( mWindGustStrength );
      stream->write( mWindTurbulenceFrequency );
      stream->write( mWindTurbulenceStrength );

      for ( S32 i=0; i < NumCoverTypes; i++ )
      {
         stream->write( mProbability[i] );
         stream->write( mSizeMin[i] );
         stream->write( mSizeMax[i] );
         stream->write( mSizeExponent[i] );
         stream->write( mWindScale[i] );
         
         stream->write( mMaxSlope[i] );
         
         stream->write( mMinElevation[i] );
         stream->write( mMaxElevation[i] );     

         stream->write( mLayer[i] );
         stream->writeFlag( mInvertLayer[i] );      

         stream->write( mMinClumpCount[i] );
         stream->write( mMaxClumpCount[i] );
         stream->write( mClumpCountExponent[i] );
         stream->write( mClumpRadius[i] );

         stream->write( mBillboardRects[i].point.x );
         stream->write( mBillboardRects[i].point.y );
         stream->write( mBillboardRects[i].extent.x );
         stream->write( mBillboardRects[i].extent.y );

         stream->writeString( mShapeFilenames[i] );
      }

      stream->writeFlag( mDebugRenderCells );
      stream->writeFlag( mDebugNoBillboards );
      stream->writeFlag( mDebugNoShapes );
      stream->writeFlag( mDebugLockFrustum );
   }

   if (stream->writeFlag(mask & TerrainBlockMask))
   {
      U32 ghostId = -1;

      if ( mTerrainBlock )
         ghostId = connection->getGhostIndex( mTerrainBlock );

      stream->write( ghostId );
   }

   return 0;  
}

void GroundCover::unpackUpdate( NetConnection *connection, BitStream *stream )
{
   Parent::unpackUpdate( connection, stream );

   if (stream->readFlag())
   {
      stream->read( &mRadius );
      stream->read( &mZOffset );
      stream->read( &mFadeRadius );
      stream->read( &mShapeCullRadius );
      stream->read( &mReflectRadiusScale );   
      stream->read( &mGridSize );
      stream->read( &mRandomSeed );
      stream->read( &mMaxPlacement );
      stream->read( &mMaxBillboardTiltAngle );

      mTextureName = stream->readSTString();

      stream->read( &mWindDirection.x );
      stream->read( &mWindDirection.y );
      stream->read( &mWindGustLength );
      stream->read( &mWindGustFrequency );
      stream->read( &mWindGustStrength );
      stream->read( &mWindTurbulenceFrequency );
      stream->read( &mWindTurbulenceStrength );

      for ( S32 i=0; i < NumCoverTypes; i++ )
      {
         stream->read( &mProbability[i] );
         stream->read( &mSizeMin[i] );
         stream->read( &mSizeMax[i] );
         stream->read( &mSizeExponent[i] );
         stream->read( &mWindScale[i] );

         stream->read( &mMaxSlope[i] );

         stream->read( &mMinElevation[i] );
         stream->read( &mMaxElevation[i] );     

         stream->read( &mLayer[i] );
         mInvertLayer[i] = stream->readFlag();

         stream->read( &mMinClumpCount[i] );
         stream->read( &mMaxClumpCount[i] );
         stream->read( &mClumpCountExponent[i] );
         stream->read( &mClumpRadius[i] );

         stream->read( &mBillboardRects[i].point.x );
         stream->read( &mBillboardRects[i].point.y );
         stream->read( &mBillboardRects[i].extent.x );
         stream->read( &mBillboardRects[i].extent.y );

         mShapeFilenames[i] = stream->readSTString();
      }

      mDebugRenderCells    = stream->readFlag();
      mDebugNoBillboards   = stream->readFlag();
      mDebugNoShapes       = stream->readFlag();
      mDebugLockFrustum    = stream->readFlag();

      // We have no way to easily know what changed, so by clearing
      // the cells we force a reinit and regeneration of the cells.
      // It's sloppy, but it works for now.
      _freeCells();
   }

   if (stream->readFlag())
      stream->read( &mTerrainGhostId );
}

void GroundCover::_initShapes()
{
   _deleteShapes();

   for ( S32 i=0; i < NumCoverTypes; i++ )
   {
      if ( !mShapeFilenames[i] || !mShapeFilenames[i][0] )
         continue;

      // Load the shape.
      Resource<TSShape> shape = ResourceManager->load(mShapeFilenames[i]);
      if ( !(bool)shape )
      {
         Con::warnf( "GroundCover::_initShapes() unable to load shape: %s", mShapeFilenames[i] );
         continue;
      }

      if ( isClientObject() && !shape->preloadMaterialList() && NetConnection::filesWereDownloaded() )
      {
         Con::warnf( "GroundCover::_initShapes() material preload failed for shape: %s", mShapeFilenames[i] );
         continue;
      }

      // Create the shape instance.
      mShapeInstances[i] = new TSShapeInstance( shape, isClientObject() );
   }
}

void GroundCover::_deleteShapes()
{
   for ( S32 i=0; i < NumCoverTypes; i++ )
   {
      delete mShapeInstances[i];
      mShapeInstances[i] = NULL;
   }
}

void GroundCover::_deleteCells()
{
   // Delete the allocation list.
   for ( S32 i=0; i < mAllocCellList.size(); i++ )
      delete mAllocCellList[i];
   mAllocCellList.clear();

   // Zero out the rest of the stuff.
   _freeCells();
}

void GroundCover::_freeCells()
{
   // Zero the grid and scratch space.
   mCellGrid.clear();
   mScratchGrid.clear();

   // Compact things... remove excess allocated cells.
   const U32 maxCells = mGridSize * mGridSize;
   if ( mAllocCellList.size() > maxCells )
   {
      for ( S32 i=maxCells; i < mAllocCellList.size(); i++ )
        delete mAllocCellList[i];
      mAllocCellList.setSize( maxCells );
   }

   // Move all the alloced cells into the free list.
   mFreeCellList.clear();
   mFreeCellList.merge( mAllocCellList );

   // Release the primitive buffer.
   mPrimBuffer = NULL;
}

void GroundCover::_recycleCell( GroundCoverCell* cell )
{
   mFreeCellList.push_back( cell );
}

void GroundCover::_initialize( U32 cellCount, U32 cellPlacementCount )
{
   // Cleanup everything... we're starting over.
   _freeCells();
   _deleteShapes();
   mTexture.free();

   // Nothing to do without a count!
   if ( cellPlacementCount == 0 )
      return;

   // Grab the terrain block.
   if ( mTerrainBlock )
   {
      mTerrainBlock->mUpdateSignal.remove( this, &GroundCover::onTerrainUpdated );
      mTerrainBlock = NULL;
   }

   // Use the net connection to resolve the ghost id.
   NetConnection* conn = NetConnection::getConnectionToServer();

   // Without a connection or id we cannot continue.
   if ( mTerrainGhostId == -1 || !conn )
      return;

   mTerrainBlock = dynamic_cast<TerrainBlock*>( conn->resolveGhost( mTerrainGhostId ) );
   if ( !mTerrainBlock || mTerrainBlock->isServerObject() )
   {
      mTerrainBlock = NULL;
      mTerrainGhostId = -1;
      return;
   }

   // Hook ourselves up to get terrain change notifications.
   mTerrainBlock->mUpdateSignal.notify( this, &GroundCover::onTerrainUpdated );

   // Reset the grid sizes.
   mCellGrid.setSize( cellCount );
   dMemset( mCellGrid.address(), 0, mCellGrid.memSize() );
   mScratchGrid.setSize( cellCount );

   // Reload the texture.
   if ( mTextureName && mTextureName[0] )
      mTexture.set( mTextureName, &GFXDefaultStaticDiffuseProfile );//&GFXMaterialStaticDXT5Profile );

   // Grab the texture aspect ratio.
   F32 texAspect = 1.0f;
   if ( !mTexture.isNull() )
      texAspect = mTexture.getWidth() / (F32)mTexture.getHeight();

   // Rebuild the texture aspect scales for each type.
   for ( S32 i=0; i < NumCoverTypes; i++ )
   {
      if ( mBillboardRects[i].len_y() > 0.0f )
         mBillboardAspectScales[i] = texAspect * ( mBillboardRects[i].len_x() / mBillboardRects[i].len_y() );
      else
         mBillboardAspectScales[i] = 0.0f;
   }

   // Load the shapes again.
   _initShapes();

   // Set the primitive buffer up for the maximum placement in a cell.
   mPrimBuffer.set( GFX, cellPlacementCount * 6, 0, GFXBufferTypeStatic );
   U16 *idxBuff;
   mPrimBuffer.lock(&idxBuff);
   for ( U32 i=0; i < cellPlacementCount; i++ )
   {
      //
      // The vertex pattern in the VB for each 
      // billboard is as follows...
      //
      //     0----1
      //     |\   |
      //     | \  |
      //     |  \ |
      //     |   \|
      //     3----2
      //
      // We setup the index order below to ensure
      // sequential, cache friendly, access.
      //
      U32 offset = i * 4;
      idxBuff[i*6+0] = 0 + offset;
      idxBuff[i*6+1] = 1 + offset;
      idxBuff[i*6+2] = 2 + offset;
      idxBuff[i*6+3] = 2 + offset;
      idxBuff[i*6+4] = 3 + offset;
      idxBuff[i*6+5] = 0 + offset;
   }   
   mPrimBuffer.unlock();

   // Generate the normalised probability.
   F32 total = 0.0f;
   for ( S32 i=0; i < NumCoverTypes; i++ )
   {
      // If the element isn't gonna render... then
      // set the probability to zero.
      if ( mShapeInstances[i] == NULL && mBillboardAspectScales[i] <= 0.0001f )
      {
         mNormalizedProbability[i] = 0.0f;
      }
      else
      {
         mNormalizedProbability[i] = mProbability[i];

         total += mProbability[i];
      }
   }
   if ( total > 0.0f )
   {
      for ( S32 i=0; i < NumCoverTypes; i++ )
         mNormalizedProbability[i] /= total;
   }
}

GroundCoverCell* GroundCover::_generateCell( const Point2I& index, 
                                             const Box3F& bounds, 
                                             U32 placementCount,
                                             S32 randSeed )
{
   PROFILE_SCOPE(GroundCover_GenerateCell);

   // Grab a free cell or allocate a new one.
   GroundCoverCell* cell;
   if ( mFreeCellList.empty() )
   {
      cell = new GroundCoverCell();
      mAllocCellList.push_back( cell );
   }
   else
   {
      cell = mFreeCellList.last();
      mFreeCellList.pop_back();
   }

   cell->mDirty = true;
   cell->mIndex = index;
   cell->mBounds = bounds;

   Point3F pos = mTerrainBlock->getPosition();

   Box3F renderBounds = bounds;
   Point3F point;
   Point3F normal;
   F32 h;
   Point2F cp, uv;
   bool hit;
   GroundCoverCell::Placement p;
   F32 rotation;
   U8 minValue;
   F32 size;
   F32 sizeExponent;
   Point2I lpos;
   //F32 value;
   VectorF right;
   bool firstElem = true;

   cell->mBillboards.clear();
   cell->mBillboards.reserve( placementCount );
   cell->mShapes.clear();
   cell->mShapes.reserve( placementCount );

   const F32 terrainSquareSize = (F32)mTerrainBlock->getSquareSize();
   const F32 oneOverTerrainLength = 1.0f / (F32)(terrainSquareSize * TerrainBlock::BlockSize);
   //const F32 oneOverTerrainSquareSize = 1.0f / terrainSquareSize;
   const GBitmap* terrainLM = mTerrainBlock->lightMap;
   
   // The RNG that we'll use in generation.
   MRandom rand( 0 );

   // We process one type at a time.
   for ( U32 type=0; type < NumCoverTypes; type++ )
   {
      // How many cover elements do we need to generate for this type?
      const S32 typeCount = mNormalizedProbability[type] * (F32)placementCount;
      if ( typeCount <= 0 )
         continue;

      // Grab the terrain layer for this type.
      /*
      const TerrainDataLayer* dataLayer = NULL;
      const bool typeInvertLayer = mInvertLayer[type];
      if ( mLayer[type] > -1 )
      {
         dataLayer = mTerrainBlock->getDataLayer( mLayer[type] );
         if ( dataLayer )
         {
            // Do an initial check to see if we can place any place anything
            // at all...  if the layer area for this element is empty then 
            // there is nothing more to do.

            RectI area( (S32)mFloor( ( bounds.min.x - pos.x ) * oneOverTerrainSquareSize ),
                        (S32)mFloor( ( bounds.min.y - pos.y ) * oneOverTerrainSquareSize ),
                        (S32)mCeil( ( bounds.max.x - pos.x ) * oneOverTerrainSquareSize ),
                        (S32)mCeil( ( bounds.max.y - pos.y ) * oneOverTerrainSquareSize ) );
            area.extent -= area.point;

            if ( dataLayer->testFill( area, typeInvertLayer ? 255 : 0 ) )
               continue;
         }
      }

      // If the layer is not inverted and we have no data 
      // then we have nothing to draw.
      if ( !typeInvertLayer && !dataLayer )
         continue;
      */

      // We set the seed we were passed which is based on this grids position
      // in the world and add the type value.  This keeps changes to one type
      // from effecting the outcome of the others.
      rand.setSeed( randSeed + type );

      // Setup for doing clumps.
      S32 clumps = 0;
      Point2F clumpCenter;
      const S32 clumpMin = getMax( 1, (S32)mMinClumpCount[type] );
      F32 clumpExponent;   

      // We mult this by -1 each billboard we make then use
      // it to scale the billboard x axis to flip them.  This
      // essentially gives us twice the variation for free.
      F32 flipBB = -1.0f;

      // Precompute a few other type specific values.
      const F32 typeSizeRange = mSizeMax[type] - mSizeMin[type];
      const F32 typeMaxSlope = mMaxSlope[type];
      const F32 typeMaxElevation = mMaxElevation[type];
      const F32 typeMinElevation = mMinElevation[type];
      const bool typeIsShape = mShapeInstances[ type ] != NULL;
      const Box3F typeShapeBounds = typeIsShape ? mShapeInstances[ type ]->getShape()->bounds : Box3F();
      const F32 typeWindScale = mWindScale[type];

      // We can set this once here... all the placements for this are the same.
      p.type = type;
      p.windAmplitude = typeWindScale;
      p.lmColor.set(1.0f,1.0f,1.0f);

      // Generate all the cover elements for this type.
      for ( S32 i=0; i < typeCount; i++ )
      {
         // Do all the other random things here first as to not 
         // disturb the random sequence if the terrain geometry
         // or cover layers change.

         // Get the random position.      
         cp.set( rand.randF(), rand.randF() );

         // Prepare the clump info.
         clumpExponent = mClampF( mPow( rand.randF(), mClumpCountExponent[type] ), 0.0f, 1.0f );
         if ( clumps <= 0 )
         {
            // We're starting a new clump.
            clumps = ( clumpMin + mFloor( ( mMaxClumpCount[type] - clumpMin ) * clumpExponent ) ) - 1;
            cp.set(  bounds.min.x + cp.x * bounds.len_x(),
                     bounds.min.y + cp.y * bounds.len_y() );
            clumpCenter = cp;
         }
         else
         {
            clumps--;
            cp.set( clumpCenter.x - ( ( cp.x - 0.5f ) * mClumpRadius[type] ),
                    clumpCenter.y - ( ( cp.y - 0.5f ) * mClumpRadius[type] ) );
         }

         // The size is calculated using an exponent to control 
         // the frequency between min and max sizes.
         sizeExponent = mClampF( mPow( rand.randF(), mSizeExponent[type] ), 0.0f, 1.0f );
         size = mSizeMin[type] + ( typeSizeRange * sizeExponent );

         // Generate a random z rotation.
         rotation = rand.randF() * M_2PI_F;

         // Generate a tolerance to test against the cover layer.
         minValue = rand.randI( 1, 255 );

         // Flip the billboard now for the next generation.
         flipBB *= -1.0f;

         PROFILE_START( GroundCover_TerrainRayCast );
         hit = mTerrainBlock->getNormalAndHeight( Point2F( cp.x - pos.x, cp.y - pos.y ), &normal, &h );
         PROFILE_END(GroundCover_TerrainRayCast); // GroundCover_TerrainRayCast
         if ( !hit || h > typeMaxElevation || h < typeMinElevation )
            continue;

         // Do we need to check slope?
         if ( !isZero( typeMaxSlope ) )
         {
            if (mAcos(normal.z) > mDegToRad(typeMaxSlope))
               continue;
         }

         point.set( cp.x, cp.y, h );

         /*
         if ( dataLayer )
         {
            lpos.set( (S32)mFloor( ( ( point.x - pos.x ) * oneOverTerrainSquareSize ) + 0.5f ), 
                      (S32)mFloor( ( ( point.y - pos.y ) * oneOverTerrainSquareSize ) + 0.5f ) );

            value = dataLayer->getValue( lpos );

            if (  typeInvertLayer && value > minValue ||
                  !typeInvertLayer && value < minValue )
                  continue;
         }
         */

         p.point = point;
         p.rotation = rotation;

         // Grab the terrain lightmap color at this position.
         //
         // TODO: Can't we remove this test?  The terrain 
         // lightmap should never be null... NEVER!
         //
         if ( terrainLM )
         {
            // TODO: We could probably call terrainLM->getBits()
            // once outside the loop then pre-calculate the scalar
            // for converting a world position into a lexel...
            // avoiding the extra protections inside of sampleTexel().

            uv.x = (point.x + pos.x) * oneOverTerrainLength;
            uv.y = (point.y + pos.y) * oneOverTerrainLength;
            uv.x -= mFloor(uv.x);
            uv.y -= mFloor(uv.y);
            p.lmColor = terrainLM->sampleTexel(uv.x,uv.y);
         }

         // Put it into the right list by type.
         //
         // TODO: Could we break up the generation into
         // two separate loops for shapes and billboards
         // and gain performance?
         //
         if ( typeIsShape )
         {
            // TODO: Convert the size into a real size... not scale!

            // TODO: We could probably cache the shape bounds
            // into a primitive array and avoid the double pointer
            // dereference per placement.

            p.size.set( size, size, size );
            p.worldBox = typeShapeBounds;
            p.worldBox.min *= size;
            p.worldBox.max *= size;
            p.worldBox.min += point;
            p.worldBox.max += point;

            cell->mShapes.push_back( p );
         }
         else
         {
            p.size.y = size;
            p.size.x = size * flipBB * mBillboardAspectScales[type]; 
            p.worldBox.max = p.worldBox.min = point;

            cell->mBillboards.push_back( p );
         }

         // Update the render bounds.
         if ( firstElem )
         {
            renderBounds = p.worldBox;
            firstElem = false;
         }
         else
         {
            renderBounds.extend( p.worldBox.min );
            renderBounds.extend( p.worldBox.max );
         }

      } // for ( S32 i=0; i < typeCount; i++ )

   } // for ( U32 type=0; type < NumCoverTypes; type++ )
      

   cell->mRenderBounds = renderBounds;
   cell->mBounds.min.z = renderBounds.min.z;
   cell->mBounds.max.z = renderBounds.max.z;

   return cell;
}

void GroundCover::onTerrainUpdated( U32 flags, const Point2I& min, const Point2I& max )
{
   AssertFatal( isClientObject(), "GroundCover::onTerrainUpdated() - Got server side terrain update!" );

   // Free all the cells if we've gotten a lightmap update.
   if ( flags & TerrainBlock::LightmapUpdate )
   {
      _freeCells();
      return;
   }

   // TODO: EmptyUpdate doesn't work yet... fix editor/terrain.

   // If this is a height or opacity update only clear
   // the cells that have changed.
   if (  flags & TerrainBlock::HeightmapUpdate || 
         flags & TerrainBlock::OpacityUpdate ||
         flags & TerrainBlock::EmptyUpdate )
   {
      // Convert the min and max into world space.
      const F32 size = mTerrainBlock->getSquareSize();
      const Point3F pos = mTerrainBlock->getPosition();

      // TODO: I don't think this works right with tiling!
      Box3F dirty(   F32( min.x * size ) + pos.x, F32( min.y * size ) + pos.y, 0.0f,
                     F32( max.x * size ) + pos.x, F32( max.y * size ) + pos.y, 0.0f );
      
      // Now free any cells that overlap it!
      for ( S32 i = 0; i < mCellGrid.size(); i++ )
      {
         GroundCoverCell* cell = mCellGrid[ i ];
         if ( !cell )
            continue;

         const Box3F& bounds = cell->getBounds();
         dirty.min.z = bounds.min.z;
         dirty.max.z = bounds.max.z;
         if ( bounds.isOverlapped( dirty ) )
         {
            mCellGrid[ i ] = NULL;
            _recycleCell( cell );
         }
      }
   }
}

void GroundCover::_updateCoverGrid( const FrustrumCuller& culler )
{
   PROFILE_SCOPE( GroundCover_UpdateCoverGrid );
   
   // How many cells in the grid?
   const U32 cells = mGridSize * mGridSize;

   // Whats the max placement count for each cell considering 
   // the grid size and quality scale LOD value.
   const S32 placementCount = ( (F32)mMaxPlacement * smQualityScale ) / F32( mGridSize * mGridSize );

   // If the cell grid isn't sized or the placement count
   // changed (most likely because of quality lod) then we
   // need to initialize the system again.
   if ( mCellGrid.empty() || placementCount != mLastPlacementCount )
   {
      _initialize( cells, placementCount );
      mLastPlacementCount = placementCount;
   }

   // Without terrain or a count... we don't function at all.
   if ( !mTerrainBlock || placementCount == 0 )
      return;

   // Clear the scratch grid.
   dMemset( mScratchGrid.address(), 0, mScratchGrid.memSize() );

   // Calculate the normal cell size here.
   const F32 cellSize = ( mRadius * 2.0f ) / (F32)(mGridSize - 1);

   // Figure out the root index of the new grid based on the camera position.
   Point2I index( (S32)mFloor( ( culler.mCamPos.x - mRadius ) / cellSize  ),
                  (S32)mFloor( ( culler.mCamPos.y - mRadius ) / cellSize ) );

   // Figure out the cell shift between the old and new grid positions.
   Point2I shift = mGridIndex - index;

   // If we've shifted more than one in either axis then we've warped.
   bool didWarp = shift.x > 1 || shift.x < -1 || 
                  shift.y > 1 || shift.y < -1 ? true : false;

   // Go thru the grid shifting each cell we find and
   // placing them in the scratch grid.
   for ( S32 i = 0; i < mCellGrid.size(); i++ )
   {
      GroundCoverCell* cell = mCellGrid[ i ];
      if ( !cell )
         continue;

      // Whats our new index?
      Point2I newIndex = cell->shiftIndex( shift );

      // Is this cell outside of the new grid?
      if (  newIndex.x < 0 || newIndex.x >= mGridSize ||
            newIndex.y < 0 || newIndex.y >= mGridSize )
      {
         _recycleCell( cell );
         continue;
      }

      // Place the cell in the scratch grid.
      mScratchGrid[ ( newIndex.y * mGridSize ) + newIndex.x ] = cell;
   }

   // Get the terrain elevation range for setting the default cell bounds.
   F32 terrainMinHeight, terrainMaxHeight;
   mTerrainBlock->getMinMaxHeight( &terrainMinHeight, &terrainMaxHeight );

   // Go thru the scratch grid copying each cell back to the
   // cell grid and creating new cells as needed.
   //
   // By limiting ourselves to only one new cell generation per
   // update we're lowering the performance hiccup during movement
   // without getting into the complexity of threading.  The delay
   // in generation is rarely noticeable in normal play.
   //
   // The only caveat is that we need to generate the entire visible
   // grid when we warp.
   U32 cellsGenerated = 0;
   for ( S32 i = 0; i < mScratchGrid.size(); i++ )
   {
      GroundCoverCell* cell = mScratchGrid[ i ];
      if ( !cell && ( cellsGenerated == 0 || didWarp ) )
      {
         // Get the index point of this new cell.
         S32 y = i / mGridSize;
         S32 x = i - ( y * mGridSize );
         Point2I newIndex = index + Point2I( x, y );

         // What will be the world placement bounds for this cell.
         Box3F bounds;
         bounds.min.set( newIndex.x * cellSize, newIndex.y * cellSize, terrainMinHeight );
         bounds.max.set( bounds.min.x + cellSize, bounds.min.y + cellSize, terrainMaxHeight );

         S32 clipMask = mCuller.testBoxVisibility( bounds, FrustrumCuller::ClipPlaneMask, 0 );
         if ( clipMask == -1 )
         {
            mCellGrid[ i ] = NULL;
            continue;
         }

         // We need to allocate a new cell.
         //
         // TODO: This is the expensive call and where we should optimize. In
         // particular the next best optimization would be to take advantage of
         // multiple cores so that we can generate all the cells in one update.
         //
         // Instead of generating the cell here we would allocate a cell and stick
         // it into a thread safe queue (maybe lockless) as well as the mCellGrid.
         // Once all were allocated we would do something like this...
         //
         // PowerEngineParallelProcess( cellsToGenerateQueue, _generateCell );
         //
         // Internally this function would pass the queue to some global pre-allocated
         // worker threads which are locked to a particular core.  While the main 
         // thread waits for the worker threads to finish it will process cells itself.
         // 
         cell = _generateCell(   newIndex - index, 
                                 bounds, 
                                 placementCount, 
                                 mRandomSeed + mAbs( newIndex.x ) + mAbs( newIndex.y ) );

         // Increment our generation count.
         ++cellsGenerated;
      }

      mCellGrid[ i ] = cell;
   }

   // Store the new grid index.
   mGridIndex = index;
}

bool GroundCover::prepRenderImage( 
   SceneState *state, 
   const U32 stateKey, 
   const U32 startZone, 
   const bool modifyBaseZoneState )
{
   // TODO: Educate myself... WTF does this accomplish?
   // Is it just a protection against double rendering?
   if ( isLastState( state, stateKey ) )
      return false;

   // Reset the rendering stats on a new scene state!
   //
   // TODO: This doesn't work with multiple ground cover
   // elements in a scene... fix me!
   //
   if ( stateKey != smLastState )
   {
      smStatRenderedCells = 0;
      smStatRenderedBillboards = 0;
      smStatRenderedBatches = 0;
      smStatRenderedShapes = 0;

      smLastState = stateKey;
   }

   setLastState( state, stateKey );

   // Check portal visibility.
   //
   // TODO: Make sure that the ground cover stops rendering
   // if you're inside a zoned interior.
   //
   if ( !state->isObjectRendered( this ) )
      return false;

   // Setup the frustum culler.
   if ( !mCuller.mSceneState || !mDebugLockFrustum )
      mCuller.init( state );

   // Update the cells.
   _updateCoverGrid( mCuller );

   // Prepare to render the grid shapes.
   PROFILE_START(GroundCover_RenderShapes);

   // Move all the allocated lights into the free list
   // to prepare for rendering.
   mLightAllocator->free();

   // We use a dummy helper object for tricking TSMesh
   // into rendering our instances.
   TSSceneObjectHelper helper;
   TSMesh::setObject( &helper );
   TSMesh::setCamTrans( GFX->getWorldMatrix() );
   TSMesh::setSceneState( state );

   GFX->pushState();
   GFX->pushWorldMatrix();

   const S32 cullerMasks = FrustrumCuller::ClipPlaneMask | FrustrumCuller::FarSphereMask;

   // TODO: Add a special fade out for DTS?
   mCuller.mFarDistance = mShapeCullRadius;

   for ( S32 i = 0; i < mCellGrid.size(); i++ )
   {
      GroundCoverCell* cell = mCellGrid[ i ];
      if ( !cell || mDebugNoShapes )
         continue;

      S32 clipMask = mCuller.testBoxVisibility( cell->getRenderBounds(), cullerMasks, 0 );
      if ( clipMask == -1 )
         continue;

      smStatRenderedCells++;

      // Render the shapes in this cell... only pass the culler if the
      // cell wasn't fully within the frustum.
      smStatRenderedShapes += cell->renderShapes(  
                                 state, 
                                 clipMask != 0 ? &mCuller : NULL, 
                                 helper,
                                 mLightAllocator,
                                 mShapeInstances );
   }

   // Cleanup.
   GFX->popWorldMatrix();
   GFX->popState();
   TSMesh::setObject( NULL );

   PROFILE_END(GroundCover_RenderShapes); // GroundCover_RenderShapes

   // Submit ourselves for rendering billboards later.
   RenderInst *ri = gRenderInstManager.allocInst();
   ri->obj = this;
   ri->state = state;
   ri->type = RenderInstManager::RIT_Foliage;
   gRenderInstManager.addInst( ri );

   return true;
}

void GroundCover::renderObject( SceneState *state, RenderInst *ri )
{
   // This sucks... there has got to be a better place
   // to get the camera transform!
   GameConnection* conn = GameConnection::getConnectionToServer();
   if ( !conn )
      return;

   if ( !mTerrainBlock )
      return;

   PROFILE_SCOPE(GroundCover_RenderBillboards);

   // Prepare to render.
   GFX->pushState();

   GFX->pushWorldMatrix();

   // Apply Z offset
   MatrixF world = GFX->getWorldMatrix();

   if(mZOffset != 0)
   {
      const F32 &zOffset = mZOffset;
      
      const F32 *b = world;
      world[8] = b[8] + zOffset * b[12];
      world[9] = b[9] + zOffset * b[13];
      world[10]= b[10]+ zOffset * b[14];
      world[11]= b[11]+ zOffset * b[15];

      GFX->setWorldMatrix( world );
   }

   // Set the projection and world transform info.
   MatrixF proj = GFX->getProjectionMatrix();
   proj.mul( world );
   proj.transpose();
   GFX->setVertexShaderConstF( 0, proj, 4 ); // VC_WORLD_PROJ

   F32 cullScale = 1.0f;
   if ( gClientSceneGraph->isReflectPass() )
      cullScale = mReflectRadiusScale;

   // Prepare to render some batches.
   MatrixF camMat;
   conn->getControlCameraTransform( 0, &camMat );
   GroundCoverCell::initRender(  ( mBBShader && mBBShader->getShader() ? mBBShader->getShader() : NULL ), 
                                 camMat, 
                                 mFadeRadius * cullScale, 
                                 mRadius * cullScale, 
                                 mDegToRad( mMaxBillboardTiltAngle ), 
                                 mTexture, 
                                 mBillboardRects );

   // Pass the damage mask from the terrain for hiding damaged billboards.
   GFX->setTexture( 2, NULL);//mTerrainBlock->getDamageMaskTexture() );
#ifdef STATEBLOCK
	AssertFatal(mSetSB, "GroundCover::renderObject -- mSetSB cannot be NULL.");
	mSetSB->apply();
#else
	GFX->setTextureStageAddressModeU( 2, GFXAddressWrap );
	GFX->setTextureStageAddressModeV( 2, GFXAddressWrap );
	GFX->setTextureStageMagFilter( 2, GFXTextureFilterPoint );
	GFX->setTextureStageMinFilter( 2, GFXTextureFilterPoint );
#endif

   Point3F terrainPos = mTerrainBlock->getPosition();
   // *** DSBOJ
   Point4F terrainData( terrainPos.x, terrainPos.y, mTerrainBlock->getSquareSize() * TerrainBlock::BlockSize, 0.0f );
   GFX->setVertexShaderConstF( 11, terrainData, 1 );

   // Pass in the sim time in seconds... wrap 
   // around when the time gets out of scale.
   const F32 simTime = Sim::getCurrentTime() * 0.001f;
   //GFX->setVertexShaderConstF( 12, (F32*)&simTime, 1 );

   // Pass the wind parameters.

   // *** DSBOJ

   Point2F windDirection( mWindDirection.x, mWindDirection.y );
   windDirection.normalize();
   GFX->setVertexShaderConstF( 12, windDirection, 1, 2 );
   GFX->setVertexShaderConstF( 13, &mWindGustLength, 1, 1 );
   F32 gustFrequency = mWindGustFrequency * simTime;
   GFX->setVertexShaderConstF( 14, &gustFrequency, 1, 1 );
   GFX->setVertexShaderConstF( 15, &mWindGustStrength, 1, 1 );
   F32 turbFrequency = mWindTurbulenceFrequency * simTime;
   GFX->setVertexShaderConstF( 16, &turbFrequency, 1, 1 );
   GFX->setVertexShaderConstF( 17, &mWindTurbulenceStrength, 1, 1 );

   // Set the far distance for billboards.
   mCuller.mFarDistance = mRadius;
   
   // Setup our culler mask here once for easy changing.
   const S32 cullerMasks = FrustrumCuller::ClipPlaneMask | FrustrumCuller::FarSphereMask;

   // Calculate the cell size plus a fudge factor
   // for searching for light and spheres.
   const F32 cellSearchDist = ( ( ( mRadius * cullScale ) * 2.0f ) / (F32)(mGridSize - 1) ) * 1.25f;

   // Grab the light manager for gathering dynamic lights!
   LightManager* lm = gClientSceneGraph->getLightManager();  
   LightInfoList lights;
   
   // Setup the sun direction and color.
   //LightInfo* sunLight = lm->getSpecialLight( LightManager::slSunLightType );
   //ColorF sunColor( sunLight->mColor );
   //sunColor *= 0.5f;
   //GFX->setVertexShaderConstF( 13, (F32*)&sunColor, 1 );
   //GFX->setVertexShaderConstF( 14, (F32*)&sunLight->mDirection, 1 );

   // We need to view direction for light and sphere selection!
   Point3F camDir;
   camMat.getColumn( 1, &camDir );

   for ( S32 i = 0; i < mCellGrid.size(); i++ )
   {
      GroundCoverCell* cell = mCellGrid[ i ];
      if ( !cell || mDebugNoBillboards )
         continue;

      S32 clipMask = mCuller.testBoxVisibility( cell->getRenderBounds(), cullerMasks, 0 );
      if ( clipMask == -1 )
         continue;

      // Find the best lights for this current view direction.
      //
      // NOTE: We use the grid size with a fudge for the far distance 
      // to help cull the lights better.  We're only looking for influences
      // that would be within this cell.
      //
      lm->setupLights( NULL, camMat.getPosition(), camDir, cellSearchDist, 4 );
      lm->getBestLights( lights );

      // Find the best wind emitters.
      WindEmitterList emitters;
      WindEmitter::findBest( camMat.getPosition(), camDir, cellSearchDist, 4, &emitters );

      // Render!
      smStatRenderedBillboards += cell->renderBillboards( lights, emitters, mPrimBuffer );

      // TODO: Eventually we may allow more than one billboard batch
      // per cell and we need to account for that!
      smStatRenderedBatches++;
   }

   // We must make a separate pass rendering the debug stuff
   // as the draw util will clobber the render state!
   if ( mDebugRenderCells )
   {
      // Used for debug drawing.
      GFXDrawUtil* drawer = GFX->getDrawUtil();
      drawer->clearBitmapModulation();

      for ( S32 i = 0; i < mCellGrid.size(); i++ )
      {
         GroundCoverCell* cell = mCellGrid[ i ];
         if ( !cell || ( cell->mBillboards.size() + cell->mShapes.size() ) == 0 )
            continue;

         S32 clipMask = mCuller.testBoxVisibility( cell->getRenderBounds(), cullerMasks, 0 );
         if ( clipMask == -1 )
            continue;
         
         drawer->drawWireCube( cell->getSize(), cell->getCenter(), ColorI( 0, 255, 0 ) );
      }
   }

   // Cleanup.
   GFX->popWorldMatrix();
   GFX->popState();
}



void GroundCover::resetStateBlock()
{
	//mSetInitSB
	GFX->beginStateBlock();
	GFX->setRenderState(GFXRSStencilEnable, false);
	GFX->setRenderState(GFXRSAlphaRef, 84);
	GFX->setRenderState(GFXRSAlphaFunc, GFXCmpGreater);
	GFX->setRenderState(GFXRSAlphaTestEnable, true);
	GFX->setRenderState(GFXRSAlphaBlendEnable, false);
	GFX->setRenderState(GFXRSZEnable, true);
	GFX->setRenderState(GFXRSCullMode, GFXCullNone);
	GFX->setSamplerState(0, GFXSAMPAddressU, GFXAddressClamp);
	GFX->setSamplerState(0, GFXSAMPAddressV, GFXAddressClamp);
	GFX->setSamplerState(1, GFXSAMPAddressU, GFXAddressClamp);
	GFX->setSamplerState(1, GFXSAMPAddressV, GFXAddressClamp);
	GFX->endStateBlock(mSetInitSB);

	//mSetSB
	GFX->beginStateBlock();
	GFX->setSamplerState(2, GFXSAMPAddressU, GFXAddressWrap);
	GFX->setSamplerState(2, GFXSAMPAddressV, GFXAddressWrap);
	GFX->setSamplerState(2, GFXSAMPMagFilter, GFXTextureFilterPoint);
	GFX->setSamplerState(2, GFXSAMPMinFilter, GFXTextureFilterPoint);
	GFX->endStateBlock(mSetSB);
}


void GroundCover::releaseStateBlock()
{
	if (mSetInitSB)
	{
		mSetInitSB->release();
	}

	if (mSetSB)
	{
		mSetSB->release();
	}
}

void GroundCover::init()
{
	if (mSetInitSB == NULL)
	{
		mSetInitSB = new GFXD3D9StateBlock;
		mSetInitSB->registerResourceWithDevice(GFX);
		mSetInitSB->mZombify = &releaseStateBlock;
		mSetInitSB->mResurrect = &resetStateBlock;

		mSetSB = new GFXD3D9StateBlock;
		resetStateBlock();
	}
}

void GroundCover::shutdown()
{
	SAFE_DELETE(mSetInitSB);
	SAFE_DELETE(mSetSB);
}


ConsoleStaticMethod( GroundCover, setQualityScale, F32, 2, 2, 
   "GroundCover.setQualityScale( F32 scale )\n"
   "Sets the global ground cover LOD scalar which controls "
   "the percentage of the maximum designed cover to put down. "
   "It scales both rendering cost and placement CPU performance. "
   "Returns the actual value set." )
{
   return GroundCover::setQualityScale( dAtof( argv[1] ) ); 
}

ConsoleStaticMethod( GroundCover, getQualityScale, F32, 1, 1, 
   "GroundCover.getQualityScale()\n"
   "Returns the global quality scale.  See GroundCover::setQualityScale()..." )
{
   return GroundCover::getQualityScale(); 
}
